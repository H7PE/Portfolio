<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bullet Time Game Prototype</title>
	<link rel="icon" href="favicon.png" type="image/png">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Condensed:wght@300;400&family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #blocker { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; }
        #instructions { width: 60%; max-width: 600px; padding: 30px; background-color: rgba(20, 0, 30, 0.85); color: #e0e0e0; text-align: center; font-family: 'Roboto Condensed', sans-serif; cursor: pointer; border-radius: 10px; border: 1px solid rgba(255, 100, 255, 0.5); box-shadow: 0 0 20px rgba(255, 100, 255, 0.3); }
        #instructions h1 { font-family: 'Orbitron', sans-serif; color: #ff69b4; font-size: 3em; margin-bottom: 20px; letter-spacing: 2px; text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff69b4; }
        #instructions h1 .char { display: inline-block; opacity: 0; }
        #instructions p { font-size: 1.1em; line-height: 1.6; margin-bottom: 15px; opacity: 0; }
        #instructions p:last-child { margin-top: 25px; font-weight: bold; color: #f0f0f0; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 10px; height: 10px; border: 1px solid rgba(255, 255, 255, 0.7); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 10; }
        #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; color: #fff; font-family: 'Press Start 2P', cursive; z-index: 100; text-align: center; }
        #gameOverText { font-size: clamp(2em, 10vw, 5em); margin-bottom: 50px; color: #ff3333; text-shadow: 0 0 8px #ff0000; }
        #gameOverText .char { display: inline-block; position: relative; }
        
        #finalKillCountText {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1.2em, 6vw, 2.2em);
            color: #ffdb4d; 
            margin-bottom: 40px;
            text-shadow: 0 0 6px #ccA500;
            opacity: 0;
            transform: scale(0.8); 
        }
        #retryButton { font-family: 'Press Start 2P', cursive; font-size: clamp(1em, 4vw, 1.5em); padding: 15px 30px; background-color: #fff; color: #111; border: 3px solid #555; cursor: pointer; border-radius: 0px; box-shadow: 5px 5px 0px #555; transition: background-color 0.2s, color 0.2s, box-shadow 0.2s, transform 0.2s; opacity: 0; }
        #retryButton:hover { background-color: #ffcc00; color: #000; box-shadow: 3px 3px 0px #cc9900; transform: translate(2px, 2px); }
        #killCounter { position: absolute; top: 20px; right: 20px; font-family: 'Orbitron', sans-serif; font-size: 2em; color: #ff69b4; text-shadow: 0 0 8px #ff69b4; z-index: 5; padding: 5px 10px; background-color: rgba(0,0,0,0.3); border-radius: 5px; opacity: 0; transform: translateY(-20px); }
        #killCounter span#killCountDisplay { display: inline-block; min-width: 1.5em; text-align: right; }
    </style>
</head>
<body>
    <div id="killCounter">Kills: <span id="killCountDisplay">0</span></div>
    <div id="crosshair"></div>
    <div id="blocker"> <div id="instructions"> <h1>Bullet Time</h1> <p>Click to Enter the Neon Void</p> <p>Move: WASD | Look & Bullet Control: Mouse | Jump: SPACE | Shoot: Click</p> <p>(Requires Pointer Lock & A Steady Mind)</p> </div> </div>
    <div id="gameOverScreen">
        <h1 id="gameOverText"></h1>
        <p id="finalKillCountText"></p>
        <button id="retryButton">RETRY</button>
    </div>
    <canvas id="gameCanvas"></canvas>

    <script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.163.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.163.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- Constants ---
        const PLAYER_FOV = 80; const PROJECTILE_FOV = 110; const PROJECTILE_SPEED = 40.0; const projectileMaxDistance = 150.0; const PROJECTILE_STEERING_SENSITIVITY = 0.0008; const PLAYER_COLLISION_RADIUS = 0.5; const MAX_ATTACKERS = 3; const BASE_ATTACKER_SPEED = 7.0; const ATTACKER_SELECTION_INTERVAL = 5000; 
        
        const DESTROY_ANIM_TIME = 0.3; 
        const DESTROY_ANIM_FLASH_COUNT = 5; 

        const MIN_TARGET_HEIGHT = 2.0; const TARGET_MAX_ROAM_RADIUS = 90.0; const TARGET_ROAM_CENTER = new THREE.Vector3(0, 20, 0);

        // --- State Variables
        let scene, camera, renderer, controls, composer; let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false; let velocity = new THREE.Vector3(); let direction = new THREE.Vector3(); let clock = new THREE.Clock(); let targets = []; let projectiles = []; let originalTargetMaterial; let perlinFloorMaterial; let stars; let crosshairElement; let playerBody; let cameraTargetProjectile = null; let targetFOV = PLAYER_FOV; let mouseDeltaX = 0; let mouseDeltaY = 0; let isGameOver = false; let isPaused = true; let attackingTargets = []; let lastAttackerSelectionTime = 0;
        let blocker, instructionsElement, gameOverScreenElement, gameOverTextElement, retryButtonElement, finalKillCountTextElement; 
        let killCounterElement, killCountDisplay, killCount = 0, killCountObject = { score: 0 };

        // --- Target Shader 
        const targetVertexShader=`varying vec2 vUv;varying vec3 vNormal;varying vec3 vWorldPosition;void main(){vUv=uv;vNormal=normal;vec4 worldPosition=modelMatrix*vec4(position,1.0);vWorldPosition=worldPosition.xyz;gl_Position=projectionMatrix*viewMatrix*worldPosition;}`;
        const targetFragmentShader = `
            precision highp float;
            uniform float time;
            uniform vec3 baseColor;
            uniform float flashOverrideFactor; 
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vWorldPosition;

            float rand(vec2 n){return fract(sin(dot(n,vec2(12.9898,4.1414)))*43758.5453);}
            float noise(vec2 p){vec2 ip=floor(p);vec2 u=fract(p);u=u*u*(3.0-2.0*u);float res=mix(mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);return res*res;}

            void main(){
                float timeEffect=sin(time*0.5)*0.5+0.5;
                vec2 distortedUv=vUv+vec2(sin(vWorldPosition.y*2.0+time*1.1)*0.1,cos(vWorldPosition.x*2.0+time*0.9)*0.1);
                float pattern=0.0;
                pattern+=sin(distortedUv.x*15.0+time*2.0)*0.3;
                pattern+=cos(distortedUv.y*15.0+time*1.5)*0.3;
                pattern+=noise(distortedUv*8.0+time*0.5)*0.4;
                pattern=fract(pattern*1.5);

                vec3 psychedelicColor=vec3(
                    sin(pattern*5.0+time*1.0+0.0)*0.5+0.5,
                    cos(pattern*5.0+time*1.1+2.0)*0.5+0.5,
                    sin(pattern*5.0+time*1.2+4.0)*0.5+0.5
                );

                
                float mixFactor = mix(0.8, 0.0, flashOverrideFactor);
                vec3 mixedColor = mix(baseColor, psychedelicColor, mixFactor);

                float lighting=dot(normalize(vNormal),normalize(vec3(0.5,0.7,1.0)))*0.3+0.7;
                lighting=clamp(lighting,0.0,1.0);
                mixedColor *= lighting; 

                gl_FragColor=vec4(mixedColor,1.0);
            }
        `;
        // --- Star/VHS Shaders ---
        const starVertexShader=`attribute float phase;attribute float size;varying float vPhase;varying float vOpacityPhase;void main(){vPhase=phase;vOpacityPhase=phase*0.5+0.5;vec4 mvPosition=modelViewMatrix*vec4(position,1.0);gl_PointSize=size*(300.0/-mvPosition.z);gl_Position=projectionMatrix*mvPosition;}`;const starFragmentShader=`precision highp float;uniform float time;uniform vec3 color;varying float vPhase;varying float vOpacityPhase;void main(){if(length(gl_PointCoord-vec2(0.5,0.5))>0.4)discard;float shimmer=sin(time*1.5+vPhase)*0.4+0.6;float opacityShimmer=sin(time*1.1+vOpacityPhase)*0.3+0.7;gl_FragColor=vec4(color*shimmer,opacityShimmer);}`;const VHSShader={uniforms:{'tDiffuse':{value:null},'time':{value:0.0},'noiseIntensity':{value:0.3},'scanlineIntensity':{value:0.15},'scanlineFrequency':{value:800.0},'colorShift':{value:0.003}},vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,fragmentShader:`precision highp float;uniform sampler2D tDiffuse;uniform float time;uniform float noiseIntensity;uniform float scanlineIntensity;uniform float scanlineFrequency;uniform float colorShift;varying vec2 vUv;float random(vec2 st){return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123+time*0.1);}void main(){vec2 uv=vUv;vec2 shiftR=vec2(uv.x-colorShift*(random(uv*0.1)-0.5),uv.y);vec2 shiftB=vec2(uv.x+colorShift*(random(uv*0.2)-0.5),uv.y);vec4 color=texture2D(tDiffuse,uv);float red=texture2D(tDiffuse,shiftR).r;float blue=texture2D(tDiffuse,shiftB).b;color=vec4(red,color.g,blue,color.a);float noise=(random(uv*vec2(1.0,2.0)*time)-0.5)*noiseIntensity;color.rgb+=noise;float scanline=sin(uv.y*scanlineFrequency+time*10.0)*0.5+0.5;float scanlineFactor=mix(1.0-scanlineIntensity,1.0,scanline);color.rgb*=scanlineFactor;color.rgb=clamp(color.rgb,0.0,1.0);gl_FragColor=color;}`};
        
        // --- Perlin Noise Floor Shader ---
        const perlinFloorVertexShader = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
        const perlinFloorFragmentShader = `
            uniform float time;
            uniform float noiseScale; 
            varying vec2 vUv;
            vec3 hsv2rgb(vec3 c) { vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0); vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www); return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y); }
            float random (vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float perlinNoise2D(vec2 st) { vec2 i = floor(st); vec2 f = fract(st); float a = random(i); float b = random(i + vec2(1.0, 0.0)); float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.y * u.x; }
            void main() {
                vec2 st = vUv * noiseScale; st.x += time * 0.1; st.y -= time * 0.07;
                float warpX = perlinNoise2D(st * 0.8 + time * 0.05) * 2.0 - 1.0; float warpY = perlinNoise2D(st * 0.8 + vec2(5.3, -3.1) + time * 0.06) * 2.0 - 1.0;
                st += vec2(warpX, warpY) * 0.4; float n = perlinNoise2D(st);
                float pattern = sin(n * 25.0 + time * 1.5); pattern = (pattern * 0.5 + 0.5);
                float hue = fract(n * 0.15 + time * 0.02); float saturation = 0.7 + 0.3 * sin(time * 0.3 + n * 5.0); float value = pattern * 0.6 + 0.5 + 0.25 * sin(time*0.5); 
                vec3 color = hsv2rgb(vec3(hue, clamp(saturation, 0.6, 1.0), clamp(value, 0.4, 1.0)));
                gl_FragColor = vec4(color, 1.0);
            }
        `;
        
        const projectileGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8); projectileGeometry.rotateX(Math.PI / 2); const projectileMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); const projectileCamOffset = new THREE.Vector3(0, 0.4, -0.8); const yawQuat = new THREE.Quaternion(); const pitchQuat = new THREE.Quaternion(); const deltaQuat = new THREE.Quaternion(); const tempVector = new THREE.Vector3();
        function animateInstructions(element) { const titleH1 = element.querySelector('h1'); if (!titleH1.querySelector('.char')) { titleH1.innerHTML = titleH1.textContent.split("").map(char => `<span class="char">${char === ' ' ? '&nbsp;' : char}</span>`).join(""); } element.querySelectorAll('p').forEach(p => gsap.set(p, {opacity: 0, y: 20})); const tl = gsap.timeline({ defaults: { ease: "power2.out" } }); tl.fromTo(titleH1.querySelectorAll('.char'), { y: 50, opacity: 0 }, { y: 0, opacity: 1, stagger: 0.05, duration: 0.7 }).fromTo(element.querySelectorAll('p'), { y: 20, opacity: 0 }, { y: 0, opacity: 1, stagger: 0.2, duration: 0.5 }, "-=0.5"); }

        function init() {
            crosshairElement = document.getElementById('crosshair'); blocker = document.getElementById('blocker'); instructionsElement = document.getElementById('instructions'); gameOverScreenElement = document.getElementById('gameOverScreen'); gameOverTextElement = document.getElementById('gameOverText'); retryButtonElement = document.getElementById('retryButton');
            finalKillCountTextElement = document.getElementById('finalKillCountText'); 
            killCounterElement = document.getElementById('killCounter'); killCountDisplay = document.getElementById('killCountDisplay');
            gsap.set(killCounterElement, {opacity: 0, y: -20}); animateInstructions(instructionsElement);

            scene = new THREE.Scene(); scene.fog = new THREE.Fog(0x110011, 30, 250);
            camera = new THREE.PerspectiveCamera(PLAYER_FOV, window.innerWidth / window.innerHeight, 0.1, 1000); camera.position.y = 1.6;
            const canvas = document.getElementById('gameCanvas');
            try { renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); renderer.setSize(window.innerWidth,window.innerHeight);renderer.setPixelRatio(window.devicePixelRatio); } catch (error) { displayError("Could not initialize WebGL."); return; }

            controls = new PointerLockControls(camera, renderer.domElement);
            instructionsElement.addEventListener('click', () => { if (!isGameOver && isPaused) controls.lock(); });
            retryButtonElement.addEventListener('click', resetGame);
            controls.addEventListener('lock', () => { if (isGameOver) return; isPaused = false; instructionsElement.style.display='none'; blocker.style.display='none'; if(cameraTargetProjectile===null){ crosshairElement.style.display='block'; controls.enabled=true; } else { controls.enabled=false; } killCounterElement.style.display = 'block'; gsap.to(killCounterElement, {opacity: 1, y: 0, duration: 0.3, ease: "power2.out"}); });
            controls.addEventListener('unlock', () => { if (!isGameOver) { isPaused = true; blocker.style.display='flex'; instructionsElement.style.display=''; animateInstructions(instructionsElement); } else { blocker.style.display='none'; instructionsElement.style.display='none'; } crosshairElement.style.display='none'; if(cameraTargetProjectile!==null){ cameraTargetProjectile=null; targetFOV=PLAYER_FOV; } if (cameraTargetProjectile === null && (isPaused || !controls.isLocked)) { controls.enabled = true; } if (isPaused || isGameOver) { gsap.to(killCounterElement, {opacity: 0, y: -20, duration: 0.2, ease: "power2.in", onComplete: () => { if (isPaused || isGameOver) killCounterElement.style.display = 'none'; }}); } });
            const playerObject = controls.getObject(); scene.add(playerObject); const bodyRadius = 0.4; const bodyHeightScale = 2.0; const playerBodyGeometry = new THREE.SphereGeometry(bodyRadius, 16, 12); playerBodyGeometry.scale(1, bodyHeightScale, 1); const playerBodyMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: true, transparent: true, opacity: 0.3 }); playerBody = new THREE.Mesh(playerBodyGeometry, playerBodyMaterial); playerBody.position.y = - (bodyRadius * bodyHeightScale * 0.5); playerObject.add(playerBody);
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); window.addEventListener('click', shootProjectile); document.addEventListener('mousemove', onDocumentMouseMove);

            try {
               
                originalTargetMaterial = new THREE.ShaderMaterial({ 
                    uniforms: { 
                        time: { value: 0.0 }, 
                        baseColor: { value: new THREE.Color(0xffffff) },
                        flashOverrideFactor: { value: 0.0 } 
                    }, 
                    vertexShader: targetVertexShader, 
                    fragmentShader: targetFragmentShader, 
                    side: THREE.DoubleSide, 
                });
                perlinFloorMaterial = new THREE.ShaderMaterial({ uniforms: { time: { value: 0.0 }, noiseScale: {value: 120.0} }, vertexShader: perlinFloorVertexShader, fragmentShader: perlinFloorFragmentShader, side: THREE.DoubleSide });
            } catch(shaderError){ displayError("Failed to create shader materials: " + shaderError.message); return; }

            const floorGeometry=new THREE.PlaneGeometry(5000,5000,1,1); floorGeometry.rotateX(-Math.PI/2); const floor=new THREE.Mesh(floorGeometry,perlinFloorMaterial); scene.add(floor);
            spawnTargets();
            const starGeometry=new THREE.BufferGeometry();const starVertices=[];const starPhases=[];const starSizes=[];
            const starCount=4500; 
            const starMinRadius=160; 
            const starMaxRadius=440; 
            for(let i=0;i<starCount;i++){const u=Math.random();const v=Math.random();const randTheta=2*Math.PI*u;const randPhi=Math.acos(2*v-1);const randRadius=THREE.MathUtils.randFloat(starMinRadius,starMaxRadius);const x=randRadius*Math.sin(randPhi)*Math.cos(randTheta);const y=randRadius*Math.sin(randPhi)*Math.sin(randTheta);const z=randRadius*Math.cos(randPhi);starVertices.push(x,y,z);starPhases.push(Math.random()*Math.PI*2);starSizes.push(Math.random()*1.5+1.0);}starGeometry.setAttribute('position',new THREE.Float32BufferAttribute(starVertices,3));starGeometry.setAttribute('phase',new THREE.Float32BufferAttribute(starPhases,1));starGeometry.setAttribute('size',new THREE.Float32BufferAttribute(starSizes,1));const starMaterial=new THREE.ShaderMaterial({uniforms:{time:{value:0.0},color:{value:new THREE.Color(0xffffff)}},vertexShader:starVertexShader,fragmentShader:starFragmentShader,transparent:true,blending:THREE.AdditiveBlending,depthWrite:false});stars=new THREE.Points(starGeometry,starMaterial);scene.add(stars);
            const ambientLight=new THREE.AmbientLight(0x606060);scene.add(ambientLight);const directionalLight=new THREE.DirectionalLight(0xffffff,0.3);directionalLight.position.set(1,1,1);scene.add(directionalLight);
            composer=new EffectComposer(renderer);const renderPass=new RenderPass(scene,camera);composer.addPass(renderPass);const vhsPass=new ShaderPass(VHSShader);vhsPass.renderToScreen=true;composer.addPass(vhsPass);
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function spawnTargets() { 
            targets.forEach(t => { if (t.parent) scene.remove(t); if (t.geometry) t.geometry.dispose(); }); targets = []; attackingTargets = []; 
            const geometries=[new THREE.BoxGeometry(2,2,2),new THREE.SphereGeometry(1.5,32,16),new THREE.IcosahedronGeometry(1.8,0),new THREE.TorusGeometry(1.2,0.5,16,50),new THREE.ConeGeometry(1,2.5,32),new THREE.TorusKnotGeometry(1,0.3,100,16)]; const targetCount=45; 
            for(let i=0;i<targetCount;i++){ 
                const g=geometries[Math.floor(Math.random()*geometries.length)].clone(); 
                const m = originalTargetMaterial.clone(); 
                m.uniforms.baseColor.value = new THREE.Color(Math.random()*0xffffff); 
                m.uniforms.time = originalTargetMaterial.uniforms.time; 
                const t=new THREE.Mesh(g,m); 
                t.position.set( (Math.random() - 0.5) * TARGET_MAX_ROAM_RADIUS * 1.1, TARGET_ROAM_CENTER.y + (Math.random() - 0.5) * 30, (Math.random() - 0.5) * TARGET_MAX_ROAM_RADIUS * 1.1 ); 
                t.rotation.set(Math.random()*2*Math.PI,Math.random()*2*Math.PI,Math.random()*2*Math.PI); 
                const baseScale = Math.random()*0.6+0.4;
                t.scale.setScalar(baseScale);
                const baseFreq = THREE.MathUtils.randFloat(0.1, 0.3); const speedMultiplier = THREE.MathUtils.randFloat(1.0, 3.0); 
                t.userData={ 
                    isDying: false, originalScaleVec: new THREE.Vector3(baseScale, baseScale, baseScale), 
                    rotationSpeed:(Math.random()-0.5)*0.02, rotationAxis:new THREE.Vector3(Math.random()-0.5,Math.random()-0.5,Math.random()-0.5).normalize(), 
                    isAttacking: false, originalBaseColor: m.uniforms.baseColor.value.clone(), kamikazeSpeed: 0, 
                    patternCenter: t.position.clone(), 
                    amp: new THREE.Vector3( THREE.MathUtils.randFloat(8, 25), THREE.MathUtils.randFloat(5, 20), THREE.MathUtils.randFloat(8, 25) ), 
                    freq: new THREE.Vector3( baseFreq * THREE.MathUtils.randFloat(0.7, 1.3) * speedMultiplier, baseFreq * THREE.MathUtils.randFloat(0.7, 1.3) * speedMultiplier, baseFreq * THREE.MathUtils.randFloat(0.7, 1.3) * speedMultiplier ), 
                    phase: new THREE.Vector3( Math.random() * Math.PI * 2, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2 ), 
                    driftVelocity: new THREE.Vector3( (Math.random() - 0.5) * 0.8, (Math.random() - 0.5) * 0.3, (Math.random() - 0.5) * 0.8 ).multiplyScalar(speedMultiplier * 0.4) 
                }; 
                g.computeBoundingSphere(); t.userData.boundingRadius=g.boundingSphere.radius * baseScale; scene.add(t); targets.push(t); 
            } 
        }
        function selectAttackers(time) { if (isGameOver || isPaused) return; if (time - lastAttackerSelectionTime < ATTACKER_SELECTION_INTERVAL / 1000) return; lastAttackerSelectionTime = time; attackingTargets = attackingTargets.filter(attacker => attacker.parent === scene && !attacker.userData.isDying); const potentialAttackers = targets.filter(t => t.parent === scene && !t.userData.isAttacking && !t.userData.isDying); while (attackingTargets.length < MAX_ATTACKERS && potentialAttackers.length > 0) { const randomIndex = Math.floor(Math.random() * potentialAttackers.length); const newAttacker = potentialAttackers.splice(randomIndex, 1)[0]; newAttacker.userData.isAttacking = true; newAttacker.userData.kamikazeSpeed = BASE_ATTACKER_SPEED * THREE.MathUtils.randFloat(1.0, 3.0); attackingTargets.push(newAttacker); if (newAttacker.material.uniforms.baseColor) { newAttacker.material.uniforms.baseColor.value.setHex(0xff0000); newAttacker.material.uniforms.flashOverrideFactor.value = 0.0; } } } 
        function onDocumentMouseMove(event) { if(cameraTargetProjectile!==null && !isPaused && !isGameOver){mouseDeltaX+=event.movementX||0;mouseDeltaY+=event.movementY||0;} }
        function onKeyDown(event) { if(isGameOver || isPaused || !controls.isLocked) return; switch(event.code){case'ArrowUp':case'KeyW':moveForward=true;break;case'ArrowLeft':case'KeyA':moveLeft=true;break;case'ArrowDown':case'KeyS':moveBackward=true;break;case'ArrowRight':case'KeyD':moveRight=true;break;case'Space':if(canJump)velocity.y+=80;canJump=false;break;}}
        function onKeyUp(event) { switch(event.code){case'ArrowUp':case'KeyW':moveForward=false;break;case'ArrowLeft':case'KeyA':moveLeft=false;break;case'ArrowDown':case'KeyS':moveBackward=false;break;case'ArrowRight':case'KeyD':moveRight=false;break;}}
        function shootProjectile() { if(!controls.isLocked || cameraTargetProjectile!==null || isGameOver || isPaused) return; const projectile=new THREE.Mesh(projectileGeometry,projectileMaterial.clone()); const cameraDirection=new THREE.Vector3();camera.getWorldDirection(cameraDirection); const cameraPosition=new THREE.Vector3();camera.getWorldPosition(cameraPosition); const projectileVelocity=cameraDirection.clone().normalize().multiplyScalar(PROJECTILE_SPEED); const positionOffset=cameraDirection.clone().normalize().multiplyScalar(1.5); projectile.position.copy(cameraPosition).add(positionOffset); projectile.quaternion.copy(camera.quaternion); projectile.userData.velocity=projectileVelocity; projectile.userData.distanceTraveled=0; projectiles.push(projectile);scene.add(projectile); cameraTargetProjectile=projectile;controls.enabled=false;crosshairElement.style.display='none';targetFOV=PROJECTILE_FOV; }

        function updateProjectiles(delta) {
            if (isGameOver || isPaused) return;
            for(let i=projectiles.length-1;i>=0;i--){ 
                const p=projectiles[i]; const currentVelocity=p.userData.velocity; 
                if(p===cameraTargetProjectile&&(mouseDeltaX!==0||mouseDeltaY!==0)){ const angleYaw=-mouseDeltaX*PROJECTILE_STEERING_SENSITIVITY;const anglePitch=-mouseDeltaY*PROJECTILE_STEERING_SENSITIVITY; const pLocalRight=new THREE.Vector3(1,0,0).applyQuaternion(p.quaternion);const worldUp=new THREE.Vector3(0,1,0); yawQuat.setFromAxisAngle(worldUp,angleYaw);pitchQuat.setFromAxisAngle(pLocalRight,anglePitch); deltaQuat.identity().multiply(yawQuat).multiply(pitchQuat); p.quaternion.premultiply(deltaQuat);currentVelocity.applyQuaternion(deltaQuat);p.userData.velocity=currentVelocity; } 
                const moveVector=currentVelocity.clone().normalize().multiplyScalar(PROJECTILE_SPEED*delta); p.position.add(moveVector);p.userData.distanceTraveled+=moveVector.length(); let projectileRemoved=false; 
                if(p.userData.distanceTraveled>projectileMaxDistance){ scene.remove(p); if(p.geometry) p.geometry.dispose(); projectiles.splice(i,1); projectileRemoved=true; 
                } else { 
                    for(let j=targets.length-1;j>=0;j--){ 
                        const target=targets[j]; 
                        if(target.parent && !target.userData.isDying && p.position.distanceTo(target.position)<target.userData.boundingRadius+0.4){ 
                            target.userData.isDying = true;
                            gsap.killTweensOf(target.scale);
                            gsap.killTweensOf(target.material.uniforms.baseColor.value);
                            gsap.killTweensOf(target.material.uniforms.flashOverrideFactor);


                            const originalScaleVec = target.userData.originalScaleVec.clone();
                            const originalColor = target.userData.originalBaseColor.clone();
                            const whiteColorVal = { r: 1, g: 1, b: 1 };

                            const destructionTL = gsap.timeline({
                                onComplete: () => {
                                    if (target.parent) scene.remove(target); 
                                }
                            });

                            
                            const numColorSegments = DESTROY_ANIM_FLASH_COUNT * 2 -1; 
                            const segmentDuration = DESTROY_ANIM_TIME / numColorSegments;
                            
                            
                            target.material.uniforms.baseColor.value.setRGB(whiteColorVal.r, whiteColorVal.g, whiteColorVal.b);
                            target.material.uniforms.flashOverrideFactor.value = 1.0;

                            
                            destructionTL.to(target.material.uniforms.baseColor.value, {
                                r: originalColor.r, g: originalColor.g, b: originalColor.b,
                                duration: segmentDuration,
                                repeat: numColorSegments -1, 
                                yoyo: true,
                                ease: "steps(1)",
                                immediateRender: false 
                            }, 0);

                           
                            destructionTL.to(target.material.uniforms.flashOverrideFactor, {
                                value: 0.0, 
                                duration: segmentDuration,
                                repeat: numColorSegments -1,
                                yoyo: true,
                                ease: "steps(1)",
                                immediateRender: false
                            }, 0);


                            
                            const scaleUpDuration = DESTROY_ANIM_TIME * 0.3; 
                            const scaleDownDuration = DESTROY_ANIM_TIME * 0.7;

                            destructionTL.to(target.scale, { 
                                x: originalScaleVec.x * 3,
                                y: originalScaleVec.y * 3,
                                z: originalScaleVec.z * 3,
                                duration: scaleUpDuration,
                                ease: "power1.out"
                            }, 0); 

                            destructionTL.to(target.scale, { 
                                x: originalScaleVec.x * 0.1,
                                y: originalScaleVec.y * 0.1,
                                z: originalScaleVec.z * 0.1,
                                duration: scaleDownDuration,
                                ease: "power1.in"
                            }, scaleUpDuration); 


                            if (target.userData.isAttacking) { attackingTargets = attackingTargets.filter(at => at !== target); target.userData.isAttacking = false; } 
                            killCount++; gsap.killTweensOf(killCountObject); gsap.to(killCountObject, { score: killCount, duration: 0.4, ease: "power2.out", onUpdate: () => { killCountDisplay.textContent = Math.round(killCountObject.score); } }); gsap.killTweensOf(killCountDisplay); gsap.fromTo(killCountDisplay, { scale: 1, y: 0 }, { scale: 2.0, y: -8, duration: 0.25, ease: "back.out(3)", yoyo: true, repeat: 1 } ); 
                            
                            scene.remove(p); if(p.geometry) p.geometry.dispose(); projectiles.splice(i,1); projectileRemoved=true; break; 
                        } 
                    } 
                } 
                if(projectileRemoved&&p===cameraTargetProjectile){ cameraTargetProjectile=null; if(controls.isLocked && !isGameOver && !isPaused){controls.enabled=true;crosshairElement.style.display='block';} targetFOV=PLAYER_FOV; } 
            }
        }

        const directionToPlayer = new THREE.Vector3();
        function updateTargets(delta, time) {
            if (isGameOver || isPaused) return;
            for(let i=targets.length-1;i>=0;i--){
                const t=targets[i];
                if(!t.parent) { targets.splice(i,1); if (t.userData.isAttacking) attackingTargets = attackingTargets.filter(at => at !== t); continue; }
                const ud = t.userData;

                if (ud.isDying) { continue; }
                
                if(t.material?.uniforms?.time){t.material.uniforms.time.value=time;} 
                
                if(t.material?.uniforms?.flashOverrideFactor && !ud.isAttacking) { 
                   
                }

                t.rotateOnAxis(ud.rotationAxis,ud.rotationSpeed); 
                if (ud.isAttacking) { 
                    directionToPlayer.subVectors(controls.getObject().position, t.position).normalize(); 
                    t.position.addScaledVector(directionToPlayer, ud.kamikazeSpeed * delta); 
                } else { 
                    ud.patternCenter.addScaledVector(ud.driftVelocity, delta); 
                    t.position.x = ud.patternCenter.x + Math.sin(time * ud.freq.x + ud.phase.x) * ud.amp.x; 
                    t.position.y = ud.patternCenter.y + Math.cos(time * ud.freq.y + ud.phase.y) * ud.amp.y; 
                    t.position.z = ud.patternCenter.z + Math.sin(time * ud.freq.z + ud.phase.z) * ud.amp.z; 
                    const centerDist = ud.patternCenter.distanceTo(TARGET_ROAM_CENTER); 
                    if (centerDist > TARGET_MAX_ROAM_RADIUS - Math.max(ud.amp.x, ud.amp.z)) { tempVector.subVectors(TARGET_ROAM_CENTER, ud.patternCenter).normalize(); if (ud.driftVelocity.dot(tempVector) < 0) ud.driftVelocity.reflect(tempVector); ud.patternCenter.addScaledVector(tempVector, 0.1); } 
                    const minYPatternCenter = MIN_TARGET_HEIGHT + ud.amp.y; const maxYPatternCenter = TARGET_ROAM_CENTER.y + 40 - ud.amp.y; 
                    if (ud.patternCenter.y < minYPatternCenter) { ud.patternCenter.y = minYPatternCenter; if(ud.driftVelocity.y < 0) ud.driftVelocity.y *= -0.8; } 
                    else if (ud.patternCenter.y > maxYPatternCenter) { ud.patternCenter.y = maxYPatternCenter; if(ud.driftVelocity.y > 0) ud.driftVelocity.y *= -0.8; } 
                    t.position.y = Math.max(t.position.y, MIN_TARGET_HEIGHT); 
                } 
            }
        }
        function updateStarfield(time) { if (isGameOver || isPaused) return; if(stars&&stars.material instanceof THREE.ShaderMaterial){stars.material.uniforms.time.value=time;}}
        function onWindowResize() { camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();renderer.setSize(window.innerWidth,window.innerHeight);composer.setSize(window.innerWidth,window.innerHeight);}
        function checkPlayerCollision() { if (isGameOver || isPaused) return; const playerWorldPos = controls.getObject().position; for (const target of targets) { if (!target.parent || target.userData.isDying) continue; const distance = playerWorldPos.distanceTo(target.position); if (distance < PLAYER_COLLISION_RADIUS + target.userData.boundingRadius) { triggerGameOver(); break; } } }
        
        function triggerGameOver() {
            if (isGameOver) return;
            isGameOver = true;
            isPaused = false;
            moveForward = false; moveBackward = false; moveLeft = false; moveRight = false;
            gsap.to(killCounterElement, {opacity: 0, y: -20, duration: 0.2, onComplete: () => { killCounterElement.style.display = 'none'; }});
            if (controls.isLocked) { controls.unlock(); } else { blocker.style.display = 'none'; instructionsElement.style.display = 'none'; }
            crosshairElement.style.display = 'none';
            gameOverScreenElement.style.display = 'flex';

            const gameOverMessage = "GAME OVER";
            gameOverTextElement.innerHTML = gameOverMessage.split("").map(char => `<span class="char">${char === ' ' ? '&nbsp;' : char}</span>`).join("");

            
            finalKillCountTextElement.textContent = `KILLS: ${killCount}`;
            gsap.set(finalKillCountTextElement, { opacity: 0, scale: 0.8 }); 

            gsap.killTweensOf("#gameOverText .char");
            gsap.killTweensOf(finalKillCountTextElement); 
            gsap.killTweensOf("#retryButton");

            gsap.fromTo("#gameOverText .char",
                { y: () => -100 - Math.random() * 100, opacity: 0, rotation: () => Math.random() * 90 - 45 },
                { y: 0, opacity: 1, rotation: 0, stagger: 0.08, duration: 0.6, ease: "elastic.out(1, 0.6)", delay: 0.1 }
            );

            
            gsap.to(finalKillCountTextElement, {
                opacity: 1,
                scale: 1,
                duration: 0.5,
                ease: "power2.out",
                delay: gameOverMessage.length * 0.08 + 0.4 
            });

            gsap.to("#retryButton", {
                opacity: 1,
                scale: 1,
                duration: 0.5,
                ease: "power2.out",
                delay: gameOverMessage.length * 0.08 + 0.7 
            });
        }

        function resetGame() {
            isGameOver = false;
            isPaused = true;
            gameOverScreenElement.style.display = 'none';

            gsap.set("#retryButton", { opacity: 0, scale: 0.8 });
            gsap.set(finalKillCountTextElement, { opacity: 0, scale: 0.8 }); 
            finalKillCountTextElement.textContent = ''; 

            projectiles.forEach(p => { if (p.parent) scene.remove(p); if (p.geometry) p.geometry.dispose(); }); projectiles = [];
            spawnTargets();
            controls.getObject().position.set(0, 1.6, 0); velocity.set(0, 0, 0); controls.getObject().rotation.set(0,0,0); camera.rotation.set(0,0,0);
            cameraTargetProjectile = null; targetFOV = PLAYER_FOV; camera.fov = PLAYER_FOV; camera.updateProjectionMatrix();
            clock.start();
            lastAttackerSelectionTime = clock.getElapsedTime();
            killCount = 0; killCountObject.score = 0; killCountDisplay.textContent = "0";
            gsap.set(killCounterElement, {opacity: 0, y: -20});
            killCounterElement.style.display = 'none';
            blocker.style.display = 'flex';
            instructionsElement.style.display = '';
            animateInstructions(instructionsElement);
            controls.enabled = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const rawDelta = clock.getDelta(); 
            const time = clock.getElapsedTime();

            if(originalTargetMaterial) originalTargetMaterial.uniforms.time.value = time;
            if(perlinFloorMaterial) perlinFloorMaterial.uniforms.time.value = time;
            if(stars?.material instanceof THREE.ShaderMaterial) stars.material.uniforms.time.value = time;
            const vhsPass = composer.passes[1]; 
            if (vhsPass?.material.uniforms.time) vhsPass.material.uniforms.time.value = time;

            if (isGameOver) { composer.render(rawDelta); return; }
            if (isPaused) { composer.render(rawDelta); return; }

            const delta = Math.min(rawDelta, 0.05); 
            
            const fovLerpFactor = 7.0; if (Math.abs(camera.fov - targetFOV) > 0.01) { camera.fov = THREE.MathUtils.lerp(camera.fov, targetFOV, fovLerpFactor * delta); camera.updateProjectionMatrix(); }
            if (cameraTargetProjectile) { if(cameraTargetProjectile.parent===scene){const offset=projectileCamOffset.clone().applyQuaternion(cameraTargetProjectile.quaternion);const camPos=cameraTargetProjectile.position.clone().add(offset);camera.position.lerp(camPos,0.15);const rotationLerpFactor=0.08;camera.quaternion.slerp(cameraTargetProjectile.quaternion,rotationLerpFactor);} else{cameraTargetProjectile=null;if(controls.isLocked){controls.enabled=true;crosshairElement.style.display='block';targetFOV=PLAYER_FOV;}}
            } else { if (controls.isLocked === true) { const moveSpeed=40.0;const gravity=9.8;const playerMass=15.0;const friction=10.0; velocity.x-=velocity.x*friction*delta;velocity.z-=velocity.z*friction*delta;velocity.y-=gravity*playerMass*delta; direction.z=Number(moveForward)-Number(moveBackward);direction.x=Number(moveRight)-Number(moveLeft);direction.normalize(); const speedMultiplier=3; if(moveForward||moveBackward)velocity.z-=direction.z*moveSpeed*delta*speedMultiplier; if(moveLeft||moveRight)velocity.x-=direction.x*moveSpeed*delta*speedMultiplier; controls.moveRight(-velocity.x*delta);controls.moveForward(-velocity.z*delta); controls.getObject().position.y+=(velocity.y*delta); if(controls.getObject().position.y<1.6){velocity.y=0;controls.getObject().position.y=1.6;canJump=true;} checkPlayerCollision(); } else { velocity.x=0;velocity.z=0; } }
            updateProjectiles(delta); updateTargets(delta, time); selectAttackers(time);
            try { composer.render(delta); } catch (renderError) { displayError("An error occurred during rendering: " + renderError.message); console.error(renderError); return; }
            mouseDeltaX = 0; mouseDeltaY = 0;
        }

        function displayError(message) { console.error(message); const b=document.getElementById('blocker'); const i=document.getElementById('instructions'); if (i) { i.innerHTML=`<h1 style="color:red;">Error</h1><p>${message}</p><p>Check console (F12).</p>`; i.style.fontFamily = 'sans-serif'; } if (b) b.style.display='flex'; if (i) i.style.display=''; if (renderer) { try {renderer.dispose();} catch(e){console.warn("Error disposing renderer", e)} } }
        if (window.WebGLRenderingContext) { try { init(); } catch (e) { displayError("Initialization failed: " + e.message); console.error(e); } } else { displayError("WebGL is not supported by your browser."); }
    </script>
</body>
</html>